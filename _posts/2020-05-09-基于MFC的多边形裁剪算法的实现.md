---
layout: post
title:  "基于MFC的多边形裁剪算法的实现"
date:   2020-05-09
categories: 计算机图形学
tags: MFC
excerpt: 使用MFC实现一个梯形的裁剪
mathjax: true
---

* content
{:toc}
## 一、新建$MFC$项目
此处就不再赘述，没有MFC基础的可以先看第一个MFC程序。设置项目名为PolygonClipping。**【注】：以下没有特殊说明的，均在PolygonClippingView.cpp文件下编程。**

## 二、宏定义设置

在适当位置设置宏。

```cpp
#define LEFT 1
#define RIGHT 2
#define BOTTOM 4
#define TOP 8
#define XL 100
#define XR 300
#define YT 150
#define YB 300
```

## 三、全局变量初始化

在适当位置设置全局变量。

```cpp
const UINT N = 8;
CPoint pt[N], pts[N], ptse[N], p[N], ptset1[N];
int flag=0;
```

## 三、窗口初始化

```cpp
void CPolygonClippingView::OnDraw(CDC* pDC)
{
	CPolygonClippingDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
	if (!pDoc)
		return;

	// TODO: 在此处为本机数据添加绘制代码
	CPen newpen(PS_SOLID, 1, RGB(255, 0, 0));
	CPen *old = pDC->SelectObject(&newpen);
	pDC->Rectangle(CRect(XL, YT, XR, YB));
	ptset1[0] = CPoint(20, 150);
	ptset1[1] = CPoint(120, 110);
	ptset1[2] = CPoint(250, 150);
	ptset1[3] = CPoint(200, 230);
	ptset1[4] = CPoint(20, 150);
	pDC->TextOutW(0, 50, L"双击鼠标左键 , 出现要剪切的多边形 ");
	pDC->SelectObject(old);
}
```

## 四、多边形初始化

类向导添加消息中的WM_LBUTTONDBLCLK处理函数。

```cpp
void CPolygonClippingView::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	// TODO: 在此添加消息处理程序代码和/或调用默认值
	CDC* pDC = GetDC();
	CPen newpen(PS_SOLID, 1, RGB(0, 0, 0));
	CPen *old = pDC->SelectObject(&newpen);
	flag = 1;
	pDC->MoveTo(ptset1[0]);
	for (int i = 1; i < 5; i++)
		pDC->LineTo(ptset1[i]);
	CView::OnLButtonDblClk(nFlags, point);
}
```

## 五、多边形裁剪算法实现

设置ID为ID_Clippolygon，添加事件处理程序。

```cpp
void CPolygonClippingView::OnClippolygon()
{
	// TODO: 在此添加命令处理程序代码
	CDC* pDC = GetDC();
	CPen newpen(PS_SOLID, 1, RGB(0, 0, 0));
	CPen *old = pDC->SelectObject(&newpen);
	if (flag != 1)
	{
		MessageBox(L"请先双击鼠标左键", L"警告！");
	}
	else
	{
		int i, k;
		int code1, code2;
		int M = 5;
		RedrawWindow();
		k = 0;
		for (i = 0; i < M; i++)
		{
			int c = 0;
			if (ptset1[i].x < XL)
				c = 1;
			else if (ptset1[i].x > XL)
				c = 0;
			code1 = c;
			c = 0;
			if (ptset1[i + 1].x < XL)
				c = 1;
			else if (ptset1[i + 1].x > XL)
				c = 0;
			code2 = c;
			if (code1 != 0 && code2 == 0)
			{
				pt[k].x = XL;
				pt[k].y = ptset1[i].y + (ptset1[i + 1].y - ptset1[i].y)*(XL - ptset1[i].x) / (ptset1[i + 1].x - ptset1[i].x);
				pt[k + 1].x = ptset1[i + 1].x;
				pt[k + 1].y = ptset1[i + 1].y;
				k = k + 2;
			}
			if (code1 == 0 && code2 == 0)
			{
				if (k == 0)
				{
					pt[k].x = ptset1[i].x;
					pt[k].y = ptset1[i].y;
					pt[k + 1].x = ptset1[i + 1].x;
					pt[k + 1].y = ptset1[i + 1].y;
					k = k + 2;
				}
				else
				{
					pt[k].x = ptset1[i + 1].x;
					pt[k].y = ptset1[i + 1].y;
					k = k + 1;
				}
			}
			if (code1 == 0 && code2 != 0)
			{
				pt[k].x = XL;
				pt[k].y = ptset1[i].y + (ptset1[i + 1].y - ptset1[i].y)*(XL - ptset1[i].x) / (ptset1[i + 1].x - ptset1[i].x);
				k++;
			}
		}
		pt[k].x = pt[0].x;
		pt[k].y = pt[0].y;
		M = k + 1;
		k = 0;
		for (i = 0; i < M; i++)
		{
			int c = 0;
			if (pt[i].x < XR)
				c = 0;
			else if (pt[i].x > XR)
				c = 2;
			code1 = c;
			c = 0;
			if (pt[i + 1].x < XR)
				c = 0;
			else if (pt[i + 1].x > XR)
				c = 2;
			code2 = c;
			if (code1 == 0 && code2 == 0)
			{
				if (k == 0)
				{
					pts[k].x = pt[i].x;
					pts[k].y = pt[i].y;
					pts[k + 1].x = pt[i + 1].x;
					pts[k + 1].y = pt[i + 1].y;
					k = k + 2;
				}
				else
				{
					pts[k].x = pt[i + 1].x;
					pts[k].y = pt[i + 1].y;
					k++;
				}
			}
			if (code1 != 0 && code2 == 0)
			{
				pts[k].x = XR;
				pts[k].y = pt[i].y + (pt[i + 1].y - pt[i].y)*(XR - pt[i].x) / (pt[i + 1].x - pt[i].x);
				pts[k + 1].x = pt[i + 1].x;
				pts[k + 1].y = pt[i + 1].y;
				k = k + 2;
			}
		}
		if (code1 == 0 && code2 != 0)
		{
			pts[k].x = XR;
			pts[k].y = pt[i].y + (pt[i + 1].y - pt[i].y)*(XR - pt[i].x) / (pt[i + 1].x - pt[i].x);
			k = k + 1;
		}
		pts[k] = pts[0];
		M = k + 1;
		k = 0;
		for (i = 0; i < M; i++)
		{
			int c = 0;
			if (pts[i].y > YB)
				c = 4;
			else if (pts[i].y < YB)
				c = 0;
			code1 = c;
			c = 0;
			if (pts[i + 1].y > YB)
				c = 4;
			else if (pts[i + 1].y < YB)
				c = 0;
			code2 = c;
			if (code1 == 0 && code2 == 0)
			{
				if (k == 0)
				{
					ptse[k].x = pts[i].x;
					ptse[k].y = pts[i].y;
					ptse[k + 1].x = pts[i + 1].x;
					ptse[k + 1].y = pts[i + 1].y;
					k = k + 2;
				}
				else
				{
					ptse[k].x = pts[i + 1].x;
					ptse[k].y = pts[i + 1].y;
					k = k + 1;
				}
			}
			if (code1 != 0 && code2 == 0)
			{
				ptse[k].y = YB;
				ptse[k].x = pts[i].x + (pts[i + 1].x - pts[i].x)*(YB - pts[i].y) / (pts[i + 1].y - pts[i + 1].y);
				ptse[k + 1].x = pts[i + 1].x;
				ptse[k + 1].y = pts[i + 1].y;
				k = k + 2;
			}
		}
		if (code1 == 0 && code2 != 0)
		{
			ptse[k].y = YB;
			ptse[k].x = pts[i].x + (pts[i + 1].x - pts[i].x)*(YB - pts[i].y) / (pts[i + 1].y - pts[i + 1].y);
			k = k + 1;
		}
		ptse[k] = ptse[0];
		M = k + 1;
		k = 0;
		for (i = 0; i < M; i++)
		{
			int c = 0;
			if (ptse[i].y > YT)
				c = 0;
			else if (ptse[i].y < YT)
				c = 1;
			code1 = c;
			c = 0;
			if (ptse[i + 1].y > YT)
				c = 0;
			else if (ptse[i + 1].y < YT)
				c = 1;
			code2 = c;
			if (code1 != 0 && code2 == 0)
			{
				p[k].y = YT;
				p[k].x = ptse[i].x + (ptse[i + 1].x - ptse[i].x)*(YT - ptse[i].y) / (ptse[i + 1].y - ptse[i].y);
				p[k + 1].x = ptse[i + 1].x;
				p[k + 1].y = ptse[i + 1].y;
				k = k + 2;
			}
			if (code1 == 0 && code2 == 0)
			{
				if (k == 0)
				{
					p[k].x = ptse[i].x;
					p[k].y = ptse[i].y;
					p[k + 1].x = ptse[i + 1].x;
					p[k + 1].y = ptse[i + 1].y;
					k = k + 2;
				}
				else
				{
					p[k].x = ptse[i + 1].x;
					p[k].y = ptse[i + 1].y;
					k = k + 1;
				}
			}
			if (code1 == 0 && code2 != 0)
			{
				p[k].y = YT;
				p[k].x = ptse[i].x + (ptse[i + 1].x - ptse[i].x)*(YT - ptse[i].y) / (ptse[i + 1].y - ptse[i].y);
				k++;
			}
		}
		p[k] = p[0];
		M = k + 1;
		pDC->MoveTo(p[0]);
		for (int j = 1; j <= M; j++)
		{
			pDC->LineTo(p[j]);
		}
	}
}
```

## 六、实现效果
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200509155318931.gif)
